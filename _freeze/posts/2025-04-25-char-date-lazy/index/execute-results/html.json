{
  "hash": "f6f581cc195ee658cb22ae5ba0fa1741",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Character to Date conversion using `lazy` queries\"\nauthor: \"Author: Kurtis Smith\"\ndate: \"2025-04-25\"\nslug: char-date-lazy\nformat:\n  html:\n    fig-width: 10\n    fig-height: 6\ncategories: [self-tech-support, dbplyr, rstats]\nimage: \"image.png\"\nsummary: \"How to convert a character string to date format through a lazy query without saving data to local memory\"\n---\n\n\n\n\n\n## Problem\n\nHow to convert a string with format DDMMYYYY, to a date type using **lazy queries**. The problem is that base r function `as.Date()` does not have a translatable SQL equivalent. More information on this is detailed in this [sql translation article](https://dbplyr.tidyverse.org/articles/sql-translation.html#known-functions).\n\nThis problem is largely addressed in the [special forms article](https://dbplyr.tidyverse.org/articles/translation-function.html#special-forms). However, no example is given for converting a character to a date data type. This post will provide this example.\n\nLike most of my self described \"self-tech-support\" post categories, it was introduced through work. Took me a while to come to the answer so here is to saving someone sometime somewhere.\n\nLet's begin with simulating a lazy connection.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load packages\nlibrary(dplyr)\nlibrary(dbplyr)\nlibrary(DT)\n\n# Create a local lazy tibble with Postgres SQL connection\ntest_tbl <- lazy_frame(char_date = c(\"01012020\", \"01022020\", \"01032020\"),\n                       con = simulate_postgres())\n\ntest_tbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT *\nFROM `df`\n```\n\n\n:::\n:::\n\n\n\n\n\n# Solution\n\nThe below provides two workable examples or at least the translations. Whilst you can denote a SQL function by using uppercase as shown in example 1, the second example does provide an explicit marker for what is to be used as-is in SQL with function `sql()`.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# example 1 \nmutate(test_tbl, date = TO_DATE(char_date, 'DDMMYYYY'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `df`.*, TO_DATE(`char_date`, 'DDMMYYYY') AS `date`\nFROM `df`\n```\n\n\n:::\n\n```{.r .cell-code}\n# example 2\nmutate(test_tbl, date = sql(\"TO_DATE(char_date, 'DDMMYYYY')\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<SQL>\nSELECT `df`.*, TO_DATE(char_date, 'DDMMYYYY') AS `date`\nFROM `df`\n```\n\n\n:::\n:::\n\n\n\n\n\n# Example (kind of)\n\nIt's \"kind of\" because it's not a direct translation applied to SQL but creating an example without having an instance of SQL is difficult. At least for free. I'll provide instruction below if you wish to follow along:\n\n1.  Head to [DB Fiddle](https://www.db-fiddle.com/)\n2.  Change SQL in the top left to Postgres SQL version 17\n3.  Copy & paste below in **Schema SQL** box\n\n```         \nCREATE TABLE test_tbl (\n  char_date varchar(8) NOT NULL\n);\nINSERT INTO test_tbl (char_date) VALUES ('01012020');\nINSERT INTO test_tbl (char_date) VALUES ('01022020');\nINSERT INTO test_tbl (char_date) VALUES ('01032020');\n```\n\n4.  Copy & paste below in **Query SQL** box\n\n```         \nSELECT char_date, pg_typeof(char_date) AS type\nFROM test_tbl;\n\nSELECT TO_DATE(char_date, 'DDMMYYYY') AS char_date, \n       pg_typeof(TO_DATE(char_date, 'DDMMYYYY')) AS type \nFROM test_tbl;\n```\n\n**Query #1**\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-9b8c9e3e2c104844bcc6\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-9b8c9e3e2c104844bcc6\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"01012020\",\"01022020\",\"01032020\"],[\"character varying\",\"character varying\",\"character varying\"]],\"container\":\"<table class=\\\"compact hover row-border\\\">\\n  <thead>\\n    <tr>\\n      <th>char_date<\\/th>\\n      <th>type<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"width\":\"200px\",\"targets\":\"_all\"},{\"name\":\"char_date\",\"targets\":0},{\"name\":\"type\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n**Query #2**\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-6e0bfafcd40df87bb421\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-6e0bfafcd40df87bb421\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"2020-01-01\",\"2020-02-01\",\"2020-03-01\"],[\"date\",\"date\",\"date\"]],\"container\":\"<table class=\\\"compact hover row-border\\\">\\n  <thead>\\n    <tr>\\n      <th>char_date<\\/th>\\n      <th>type<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"width\":\"200px\",\"targets\":\"_all\"},{\"name\":\"char_date\",\"targets\":0},{\"name\":\"type\",\"targets\":1}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\nQuery 2 shows the output of the translated mutate from **Solution** albeit manually added into SQL.\n\n# Consider\n\nThe flavour of SQL for this example was be PostgreSQL version 17. Not all SQL flavours support the `TO_DATE` function, below is a short and not exhaustive list.\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"datatables html-widget html-fill-item\" id=\"htmlwidget-4260281dd1eefacee686\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-4260281dd1eefacee686\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"Oracle\",\"PostgreSQL\",\"IBM Informix\",\"Snowflake\",\"Amazon Redshift\",\"Teradata\",\"InterSystems IRIS\",\"MySQL\",\"SQL Server\",\"SQLite\"],[\"TO_DATE(char, format)\",\"TO_DATE(text, format)\",\"TO_DATE(char_expression, format_string)\",\"TO_DATE(expression[, format])\",\"TO_DATE(string, format[, is_strict])\",\"TO_DATE(string_expr, format_arg)\",\"TO_DATE(date_string, format)\",\"STR_TO_DATE(string, format)\",\"CONVERT(DATE, string, style) / CAST(string AS DATE)\",\"DATE(time_value[, modifier,â€¦])\"],[\"Yes\",\"Yes\",\"Yes\",\"Yes\",\"Yes\",\"Yes\",\"Yes\",\"No\",\"No\",\"No\"]],\"container\":\"<table class=\\\"compact hover row-border\\\">\\n  <thead>\\n    <tr>\\n      <th>dialect<\\/th>\\n      <th>function_syntax<\\/th>\\n      <th>to_date_supported<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"dom\":\"t\",\"columnDefs\":[{\"name\":\"dialect\",\"targets\":0},{\"name\":\"function_syntax\",\"targets\":1},{\"name\":\"to_date_supported\",\"targets\":2}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n\n\n\n\n# Conclusion\n\nLazy all the way! My blocker, this date field as a character, was keeping my lazy queries from continued laziness. Thankfully there was a workaround. The blog does miss the step of directly showing the translated mutate query a SQL database but I hope this example from two sides helps.\n\n## Acknowledgements\n\n[r-bloggers.com](r-bloggers.com) for the reach, platform, and content\n\n[DB Fiddle](https://www.db-fiddle.com/) for SQL sandpit\n\nPackages and package maintainer(s):\n\n-   dplyr \\| Hadley Wickham\n-   dbplyr \\| Hadley Wickham\n-   DT \\| Joe Cheng\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.33/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.13.6/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.13.6/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.1/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.1/js/crosstalk.min.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}